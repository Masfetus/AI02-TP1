"Exercice 1"

(defun reverseA(arg1 arg2 arg3)
    (list arg3 arg2 arg1)
)

(defun reverseB(L)
    (let ((listDoubled '()))
    (dolist (elem L)
        (push elem listDoubled)
    )
    listDoubled
))
(defun reverseC(L)
    (let ((listDoubled '()))
    (dolist (elem L)
        (push elem listDoubled)
    )
    listDoubled
))

(defun double(L)
    (let ((listDoubled '()))
    (dolist (elem (reverse L))
        (push elem listDoubled)
        (if (atom elem)
            (push elem listDoubled)
        )
    )
    listDoubled
))
(defun nombres3 (L)
    (if (and (and (numberp (car L)) (numberp (cadr L))) (numberp (caddr L))) "BRAVO" "PERDU")
)
(defun grouper(L1 L2)
    (let ((groupedList '()))
    (loop for idx from 1 to (length L1)
        do (push (list (nth (- (length L1) idx) L1) (nth (- (length L2) idx) L2)) groupedList)
    )
    groupedList
))
(defun monReverse(L)
    (let ((listDoubled '()))
    (dolist (elem L)
        (push elem listDoubled)
    )
)
(defun palindrome(L)
    (equal (reverse L) L)
)
"Exercice 2"
(defun list-triple-couple(L)
    (mapcar (lambda (x) (list x (* 3 x))) L)
)

"Exercice 3"
(defun cles(a-list)
    (mapcar (lambda (assoc) (car assoc)) a-list)
)
(defun creation(listeCles listeVal)
    (funcall 'grouper listeCles listeVal)
)
(defun my-assoc (cle a-list)
    (mapcar (lambda (x) (if (not (equal (member cle x) nil)) (member cle x))) a-list)
)